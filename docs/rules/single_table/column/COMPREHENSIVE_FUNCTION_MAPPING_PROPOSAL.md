# üéØ –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ï –ü–†–ï–î–õ–û–ñ–ï–ù–ò–ï –ü–û –û–ü–†–ï–î–ï–õ–ï–ù–ò–Æ –¶–ï–õ–ï–í–´–• –§–£–ù–ö–¶–ò–ô –î–õ–Ø –í–°–ï–• –¢–ò–ü–û–í –û–ë–™–ï–ö–¢–û–í

## üéØ –ù–ê–ó–ù–ê–ß–ï–ù–ò–ï –î–û–ö–£–ú–ï–ù–¢–ê

–î–∞–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é —Ü–µ–ª–µ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –Ω–∞ —ç—Ç–∞–ø–µ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–Ω–µ—à–Ω–∏—Ö –∫–ª—é—á–µ–π –¥–ª—è —Å–≤—è–∑–∏ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –º–∞–ø–ø–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏–π.

---

## üìä –¢–ï–ö–£–©–ï–ï –°–û–°–¢–û–Ø–ù–ò–ï –í–°–ï–• –¢–ò–ü–û–í –û–ë–™–ï–ö–¢–û–í

### **–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å–ª—É—á–∞–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π:**
- **–ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:** 17 —Å–ª—É—á–∞–µ–≤ (getdate())
- **–í—ã—á–∏—Å–ª—è–µ–º—ã–µ –∫–æ–ª–æ–Ω–∫–∏:** 67 –∫–æ–ª–æ–Ω–æ–∫ (isnull(), len(), upper(), lower(), –∏ –¥—Ä.)
- **CHECK –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:** 31 –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ (—Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –Ω–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –≤—ã—Å–æ–∫–∏–π)
- **–ò–Ω–¥–µ–∫—Å—ã:** 150 –∏–Ω–¥–µ–∫—Å–æ–≤ (—Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –Ω–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª —Å—Ä–µ–¥–Ω–∏–π)
- **–ò—Ç–æ–≥–æ:** 84 —Ç–µ–∫—É—â–∏—Ö —Å–ª—É—á–∞—è + 181 –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Å–ª—É—á–∞–π = 265 –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤

### **–ü—Ä–æ–±–ª–µ–º–∞ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–¥—Ö–æ–¥–∞:**
- –ù–µ–ø–æ–ª–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –±—É–¥—É—â–∏–º —Ñ—É–Ω–∫—Ü–∏—è–º
- –ù–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –∫ —Ä–∞–∑–Ω—ã–º —Ç–∏–ø–∞–º –æ–±—ä–µ–∫—Ç–æ–≤
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π –≤ –Ω–æ–≤—ã—Ö –º–µ—Å—Ç–∞—Ö

---

## üöÄ –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï –° –í–ù–ï–®–ù–ò–ú–ò –ö–õ–Æ–ß–ê–ú–ò –î–õ–Ø –í–°–ï–• –¢–ò–ü–û–í

### **üèóÔ∏è –ü–û–õ–ù–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –° –í–ù–ï–®–ù–ò–ú–ò –ö–õ–Æ–ß–ê–ú–ò**

#### **1. –°–ø—Ä–∞–≤–æ—á–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)**

```sql
-- –°–æ–∑–¥–∞–Ω–∏–µ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏–π
CREATE TABLE mcl.function_mapping_rules (
    id SERIAL PRIMARY KEY,
    source_function VARCHAR NOT NULL,
    target_function VARCHAR NOT NULL,
    mapping_pattern TEXT NOT NULL,
    replacement_pattern TEXT NOT NULL,
    mapping_type VARCHAR NOT NULL DEFAULT 'direct', -- direct, regex, custom
    complexity_level INTEGER DEFAULT 1, -- 1=simple, 2=complex, 3=custom
    applicable_objects TEXT[] DEFAULT '{}', -- –º–∞—Å—Å–∏–≤ —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤: {'default_constraint', 'computed_column', 'check_constraint', 'index'}
    description TEXT,
    examples TEXT[],
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
CREATE INDEX idx_function_mapping_rules_source ON mcl.function_mapping_rules(source_function);
CREATE INDEX idx_function_mapping_rules_type ON mcl.function_mapping_rules(mapping_type);
CREATE INDEX idx_function_mapping_rules_active ON mcl.function_mapping_rules(is_active);
CREATE INDEX idx_function_mapping_rules_objects ON mcl.function_mapping_rules USING GIN(applicable_objects);
```

#### **2. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã default constraints**

```sql
-- –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã postgres_default_constraints
ALTER TABLE mcl.postgres_default_constraints 
ADD COLUMN function_mapping_rule_id INTEGER,
ADD COLUMN postgres_definition TEXT,
ADD COLUMN mapping_status VARCHAR DEFAULT 'pending', -- pending, mapped, error
ADD COLUMN mapping_complexity VARCHAR DEFAULT 'simple', -- simple, complex, custom
ADD COLUMN mapping_notes TEXT;

-- –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –∫–ª—é—á–∞
ALTER TABLE mcl.postgres_default_constraints 
ADD CONSTRAINT fk_default_function_mapping
FOREIGN KEY (function_mapping_rule_id)
REFERENCES mcl.function_mapping_rules(id)
ON DELETE SET NULL
ON UPDATE CASCADE;

-- –ò–Ω–¥–µ–∫—Å—ã
CREATE INDEX idx_postgres_default_constraints_mapping ON mcl.postgres_default_constraints(function_mapping_rule_id);
CREATE INDEX idx_postgres_default_constraints_status ON mcl.postgres_default_constraints(mapping_status);
```

#### **3. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã computed columns**

```sql
-- –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã postgres_columns –¥–ª—è computed columns
ALTER TABLE mcl.postgres_columns 
ADD COLUMN computed_function_mapping_rule_id INTEGER,
ADD COLUMN postgres_computed_definition TEXT,
ADD COLUMN computed_mapping_status VARCHAR DEFAULT 'pending', -- pending, mapped, error
ADD COLUMN computed_mapping_complexity VARCHAR DEFAULT 'simple', -- simple, complex, custom
ADD COLUMN computed_mapping_notes TEXT;

-- –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –∫–ª—é—á–∞
ALTER TABLE mcl.postgres_columns 
ADD CONSTRAINT fk_computed_function_mapping
FOREIGN KEY (computed_function_mapping_rule_id)
REFERENCES mcl.function_mapping_rules(id)
ON DELETE SET NULL
ON UPDATE CASCADE;

-- –ò–Ω–¥–µ–∫—Å—ã
CREATE INDEX idx_postgres_columns_computed_mapping ON mcl.postgres_columns(computed_function_mapping_rule_id);
CREATE INDEX idx_postgres_columns_computed_status ON mcl.postgres_columns(computed_mapping_status);
```

#### **4. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã CHECK constraints**

```sql
-- –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã postgres_check_constraints
ALTER TABLE mcl.postgres_check_constraints 
ADD COLUMN function_mapping_rule_id INTEGER,
ADD COLUMN postgres_definition TEXT,
ADD COLUMN mapping_status VARCHAR DEFAULT 'pending', -- pending, mapped, error
ADD COLUMN mapping_complexity VARCHAR DEFAULT 'simple', -- simple, complex, custom
ADD COLUMN mapping_notes TEXT;

-- –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –∫–ª—é—á–∞
ALTER TABLE mcl.postgres_check_constraints 
ADD CONSTRAINT fk_check_function_mapping
FOREIGN KEY (function_mapping_rule_id)
REFERENCES mcl.function_mapping_rules(id)
ON DELETE SET NULL
ON UPDATE CASCADE;

-- –ò–Ω–¥–µ–∫—Å—ã
CREATE INDEX idx_postgres_check_constraints_mapping ON mcl.postgres_check_constraints(function_mapping_rule_id);
CREATE INDEX idx_postgres_check_constraints_status ON mcl.postgres_check_constraints(mapping_status);
```

#### **5. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –∏–Ω–¥–µ–∫—Å–æ–≤**

```sql
-- –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã postgres_indexes
ALTER TABLE mcl.postgres_indexes 
ADD COLUMN function_mapping_rule_id INTEGER,
ADD COLUMN postgres_definition TEXT,
ADD COLUMN mapping_status VARCHAR DEFAULT 'pending', -- pending, mapped, error
ADD COLUMN mapping_complexity VARCHAR DEFAULT 'simple', -- simple, complex, custom
ADD COLUMN mapping_notes TEXT;

-- –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –∫–ª—é—á–∞
ALTER TABLE mcl.postgres_indexes 
ADD CONSTRAINT fk_index_function_mapping
FOREIGN KEY (function_mapping_rule_id)
REFERENCES mcl.function_mapping_rules(id)
ON DELETE SET NULL
ON UPDATE CASCADE;

-- –ò–Ω–¥–µ–∫—Å—ã
CREATE INDEX idx_postgres_indexes_mapping ON mcl.postgres_indexes(function_mapping_rule_id);
CREATE INDEX idx_postgres_indexes_status ON mcl.postgres_indexes(mapping_status);
```

---

## üîÆ –ü–û–¢–ï–ù–¶–ò–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –í CHECK –û–ì–†–ê–ù–ò–ß–ï–ù–ò–Ø–• –ò –ò–ù–î–ï–ö–°–ê–•

### **CHECK –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏:**

| –ü—Ä–∏–º–µ—Ä | MS SQL Server | PostgreSQL | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ |
|--------|---------------|------------|------------|
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞—Ç—ã** | `CHECK (created_date > getdate())` | `CHECK (created_date > NOW())` | –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è |
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã** | `CHECK (len(description) > 0)` | `CHECK (LENGTH(description) > 0)` | –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª–∏–Ω—ã —Ç–µ–∫—Å—Ç–∞ |
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ NULL** | `CHECK (isnull(code, '') != '')` | `CHECK (COALESCE(code, '') != '')` | –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞–ª–∏—á–∏—è –∑–Ω–∞—á–µ–Ω–∏—è |
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞** | `CHECK (len(phone) >= 10)` | `CHECK (LENGTH(phone) >= 10)` | –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö |
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞** | `CHECK (year(birth_date) >= 1900)` | `CHECK (EXTRACT(YEAR FROM birth_date) >= 1900)` | –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –¥–∞—Ç |

### **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã:**

| –ü—Ä–∏–º–µ—Ä | MS SQL Server | PostgreSQL | –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ |
|--------|---------------|------------|------------|
| **–ò–Ω–¥–µ–∫—Å –ø–æ —Ñ—É–Ω–∫—Ü–∏–∏** | `CREATE INDEX idx_name ON table (upper(name))` | `CREATE INDEX idx_name ON table (UPPER(name))` | –ü–æ–∏—Å–∫ –±–µ–∑ —É—á–µ—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞ |
| **–ò–Ω–¥–µ–∫—Å –ø–æ –¥–∞—Ç–µ** | `CREATE INDEX idx_date ON table (year(created_date))` | `CREATE INDEX idx_date ON table (EXTRACT(YEAR FROM created_date))` | –ò–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –≥–æ–¥—É |
| **–ò–Ω–¥–µ–∫—Å –ø–æ NULL** | `CREATE INDEX idx_code ON table (isnull(code, 'DEFAULT'))` | `CREATE INDEX idx_code ON table (COALESCE(code, 'DEFAULT'))` | –ò–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∑–∞–º–µ–Ω–æ–π NULL |
| **–°–ª–æ–∂–Ω—ã–π –∏–Ω–¥–µ–∫—Å** | `CREATE INDEX idx_complex ON table (upper(isnull(name, '')))` | `CREATE INDEX idx_complex ON table (UPPER(COALESCE(name, '')))` | –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ |

---

## üîß –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –¶–ï–õ–ï–í–´–• –§–£–ù–ö–¶–ò–ô

### **–≠—Ç–∞–ø 1: –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞**

```python
def create_universal_function_mapping_rules() -> bool:
    """
    –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏–π
    """
    cursor.execute('''
        INSERT INTO mcl.function_mapping_rules 
        (source_function, target_function, mapping_pattern, replacement_pattern, mapping_type, complexity_level, applicable_objects, description) 
        VALUES
        -- –ü—Ä–æ—Å—Ç—ã–µ –∑–∞–º–µ–Ω—ã (–ø—Ä–∏–º–µ–Ω–∏–º—ã –∫–æ –≤—Å–µ–º —Ç–∏–ø–∞–º –æ–±—ä–µ–∫—Ç–æ–≤)
        ('getdate', 'NOW', 'getdate\\s*\\(\\s*\\)', 'NOW()', 'direct', 1, 
         ARRAY['default_constraint', 'computed_column', 'check_constraint'], 
         '–ó–∞–º–µ–Ω–∞ getdate() –Ω–∞ NOW()'),
        
        ('isnull', 'COALESCE', 'isnull\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)', 'COALESCE(\\1, \\2)', 'regex', 1,
         ARRAY['default_constraint', 'computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ isnull(expr1, expr2) –Ω–∞ COALESCE(expr1, expr2)'),
        
        ('len', 'LENGTH', 'len\\s*\\(\\s*([^)]+)\\s*\\)', 'LENGTH(\\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ len() –Ω–∞ LENGTH()'),
        
        ('upper', 'UPPER', 'upper\\s*\\(\\s*([^)]+)\\s*\\)', 'UPPER(\\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ upper() –Ω–∞ UPPER()'),
        
        ('lower', 'LOWER', 'lower\\s*\\(\\s*([^)]+)\\s*\\)', 'LOWER(\\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ lower() –Ω–∞ LOWER()'),
        
        -- –°–ª–æ–∂–Ω—ã–µ –∑–∞–º–µ–Ω—ã
        ('substring', 'SUBSTRING', 'substring\\s*\\(\\s*([^,]+)\\s*,\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)', 'SUBSTRING(\\1 FROM \\2 FOR \\3)', 'regex', 2,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ substring(str, start, length) –Ω–∞ SUBSTRING(str FROM start FOR length)'),
        
        ('convert', 'CAST', 'convert\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)', 'CAST(\\2 AS \\1)', 'regex', 2,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ convert(datatype, expression) –Ω–∞ CAST(expression AS datatype)'),
        
        -- –§—É–Ω–∫—Ü–∏–∏ –¥–∞—Ç
        ('dateadd', 'DATE_ADD', 'dateadd\\s*\\(\\s*([^,]+)\\s*,\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)', '\\3 + INTERVAL \\2 \\1', 'regex', 2,
         ARRAY['computed_column', 'check_constraint'],
         '–ó–∞–º–µ–Ω–∞ dateadd(datepart, number, date) –Ω–∞ date + INTERVAL number datepart'),
        
        ('datediff', 'DATE_PART', 'datediff\\s*\\(\\s*([^,]+)\\s*,\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)', 'DATE_PART(\\1, \\3) - DATE_PART(\\1, \\2)', 'regex', 3,
         ARRAY['computed_column', 'check_constraint'],
         '–ó–∞–º–µ–Ω–∞ datediff(datepart, startdate, enddate) –Ω–∞ DATE_PART(datepart, enddate) - DATE_PART(datepart, startdate)'),
        
        ('year', 'EXTRACT', 'year\\s*\\(\\s*([^)]+)\\s*\\)', 'EXTRACT(YEAR FROM \\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ year(date) –Ω–∞ EXTRACT(YEAR FROM date)'),
        
        ('month', 'EXTRACT', 'month\\s*\\(\\s*([^)]+)\\s*\\)', 'EXTRACT(MONTH FROM \\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ month(date) –Ω–∞ EXTRACT(MONTH FROM date)'),
        
        ('day', 'EXTRACT', 'day\\s*\\(\\s*([^)]+)\\s*\\)', 'EXTRACT(DAY FROM \\1)', 'regex', 1,
         ARRAY['computed_column', 'check_constraint', 'index'],
         '–ó–∞–º–µ–Ω–∞ day(date) –Ω–∞ EXTRACT(DAY FROM date)')
    ''')
    
    return True
```

### **–≠—Ç–∞–ø 2: –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏**

```python
def analyze_and_link_all_objects_to_rules(task_id: int) -> Dict:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –∏ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –º–∞–ø–ø–∏–Ω–≥–∞
    """
    results = {
        'default_constraints_processed': 0,
        'computed_columns_processed': 0,
        'check_constraints_processed': 0,
        'indexes_processed': 0,
        'rules_applied': {},
        'errors': []
    }
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ default constraints
    process_default_constraints(task_id, results)
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ computed columns
    process_computed_columns(task_id, results)
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ CHECK constraints
    process_check_constraints(task_id, results)
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–¥–µ–∫—Å–æ–≤
    process_indexes(task_id, results)
    
    return results

def process_default_constraints(task_id: int, results: Dict) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ default constraints"""
    cursor.execute('''
        SELECT 
            pdc.id,
            pdc.definition,
            pt.object_name
        FROM mcl.postgres_default_constraints pdc
        JOIN mcl.postgres_tables pt ON pdc.table_id = pt.id
        JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
        WHERE mt.task_id = %s
            AND pdc.definition IS NOT NULL
    ''', (task_id,))
    
    for constraint_id, definition, table_name in cursor.fetchall():
        rule_id = find_and_apply_mapping_rule(definition, 'default_constraint')
        if rule_id:
            postgres_definition = apply_rule_to_definition(definition, rule_id)
            
            cursor.execute('''
                UPDATE mcl.postgres_default_constraints 
                SET 
                    function_mapping_rule_id = %s,
                    postgres_definition = %s,
                    mapping_status = 'mapped',
                    mapping_complexity = (
                        SELECT CASE 
                            WHEN complexity_level = 1 THEN 'simple'
                            WHEN complexity_level = 2 THEN 'complex'
                            ELSE 'custom'
                        END
                        FROM mcl.function_mapping_rules 
                        WHERE id = %s
                    )
                WHERE id = %s
            ''', (rule_id, postgres_definition, rule_id, constraint_id))
            
            results['default_constraints_processed'] += 1
            results['rules_applied'][rule_id] = results['rules_applied'].get(rule_id, 0) + 1

def process_computed_columns(task_id: int, results: Dict) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ computed columns"""
    cursor.execute('''
        SELECT 
            pc.id,
            pc.computed_definition,
            pt.object_name,
            pc.column_name
        FROM mcl.postgres_columns pc
        JOIN mcl.postgres_tables pt ON pc.table_id = pt.id
        JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
        WHERE mt.task_id = %s
            AND pc.computed_definition IS NOT NULL
    ''', (task_id,))
    
    for column_id, definition, table_name, column_name in cursor.fetchall():
        rule_id = find_and_apply_mapping_rule(definition, 'computed_column')
        if rule_id:
            postgres_definition = apply_rule_to_definition(definition, rule_id)
            
            cursor.execute('''
                UPDATE mcl.postgres_columns 
                SET 
                    computed_function_mapping_rule_id = %s,
                    postgres_computed_definition = %s,
                    computed_mapping_status = 'mapped',
                    computed_mapping_complexity = (
                        SELECT CASE 
                            WHEN complexity_level = 1 THEN 'simple'
                            WHEN complexity_level = 2 THEN 'complex'
                            ELSE 'custom'
                        END
                        FROM mcl.function_mapping_rules 
                        WHERE id = %s
                    )
                WHERE id = %s
            ''', (rule_id, postgres_definition, rule_id, column_id))
            
            results['computed_columns_processed'] += 1
            results['rules_applied'][rule_id] = results['rules_applied'].get(rule_id, 0) + 1

def process_check_constraints(task_id: int, results: Dict) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ CHECK constraints"""
    cursor.execute('''
        SELECT 
            pcc.id,
            pcc.definition,
            pt.object_name,
            pcc.constraint_name
        FROM mcl.postgres_check_constraints pcc
        JOIN mcl.postgres_tables pt ON pcc.table_id = pt.id
        JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
        WHERE mt.task_id = %s
            AND pcc.definition IS NOT NULL
    ''', (task_id,))
    
    for constraint_id, definition, table_name, constraint_name in cursor.fetchall():
        rule_id = find_and_apply_mapping_rule(definition, 'check_constraint')
        if rule_id:
            postgres_definition = apply_rule_to_definition(definition, rule_id)
            
            cursor.execute('''
                UPDATE mcl.postgres_check_constraints 
                SET 
                    function_mapping_rule_id = %s,
                    postgres_definition = %s,
                    mapping_status = 'mapped',
                    mapping_complexity = (
                        SELECT CASE 
                            WHEN complexity_level = 1 THEN 'simple'
                            WHEN complexity_level = 2 THEN 'complex'
                            ELSE 'custom'
                        END
                        FROM mcl.function_mapping_rules 
                        WHERE id = %s
                    )
                WHERE id = %s
            ''', (rule_id, postgres_definition, rule_id, constraint_id))
            
            results['check_constraints_processed'] += 1
            results['rules_applied'][rule_id] = results['rules_applied'].get(rule_id, 0) + 1

def process_indexes(task_id: int, results: Dict) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–¥–µ–∫—Å–æ–≤"""
    cursor.execute('''
        SELECT 
            pi.id,
            pi.definition,
            pt.object_name,
            pi.index_name
        FROM mcl.postgres_indexes pi
        JOIN mcl.postgres_tables pt ON pi.table_id = pt.id
        JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
        WHERE mt.task_id = %s
            AND pi.definition IS NOT NULL
    ''', (task_id,))
    
    for index_id, definition, table_name, index_name in cursor.fetchall():
        rule_id = find_and_apply_mapping_rule(definition, 'index')
        if rule_id:
            postgres_definition = apply_rule_to_definition(definition, rule_id)
            
            cursor.execute('''
                UPDATE mcl.postgres_indexes 
                SET 
                    function_mapping_rule_id = %s,
                    postgres_definition = %s,
                    mapping_status = 'mapped',
                    mapping_complexity = (
                        SELECT CASE 
                            WHEN complexity_level = 1 THEN 'simple'
                            WHEN complexity_level = 2 THEN 'complex'
                            ELSE 'custom'
                        END
                        FROM mcl.function_mapping_rules 
                        WHERE id = %s
                    )
                WHERE id = %s
            ''', (rule_id, postgres_definition, rule_id, index_id))
            
            results['indexes_processed'] += 1
            results['rules_applied'][rule_id] = results['rules_applied'].get(rule_id, 0) + 1

def find_and_apply_mapping_rule(definition: str, usage_type: str) -> int:
    """
    –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –ø—Ä–∞–≤–∏–ª–∞ –º–∞–ø–ø–∏–Ω–≥–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º —Ç–∏–ø–∞ –æ–±—ä–µ–∫—Ç–∞
    """
    cursor.execute('''
        SELECT 
            id,
            source_function,
            mapping_pattern,
            replacement_pattern,
            mapping_type,
            complexity_level
        FROM mcl.function_mapping_rules
        WHERE is_active = TRUE
            AND %s = ANY(applicable_objects)
        ORDER BY complexity_level, source_function
    ''', (usage_type,))
    
    rules = cursor.fetchall()
    
    for rule_id, source_func, pattern, replacement, mapping_type, complexity in rules:
        if source_func in definition.lower():
            return rule_id
    
    return None
```

### **–≠—Ç–∞–ø 3: –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∏ –æ—Ç—á–µ—Ç—ã**

```python
def validate_universal_function_mappings(task_id: int) -> Dict:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã—Ö –º–∞–ø–ø–∏–Ω–≥–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤
    """
    validation_results = {
        'total_objects': 0,
        'mapped_objects': 0,
        'unmapped_objects': 0,
        'object_type_breakdown': {},
        'rule_usage_statistics': {},
        'coverage_analysis': {},
        'errors': []
    }
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º —Ç–∏–ø–∞–º –æ–±—ä–µ–∫—Ç–æ–≤
    object_types = [
        ('default_constraints', 'postgres_default_constraints', 'function_mapping_rule_id'),
        ('computed_columns', 'postgres_columns', 'computed_function_mapping_rule_id'),
        ('check_constraints', 'postgres_check_constraints', 'function_mapping_rule_id'),
        ('indexes', 'postgres_indexes', 'function_mapping_rule_id')
    ]
    
    for object_type, table_name, fk_field in object_types:
        cursor.execute(f'''
            SELECT 
                COUNT(*) as total,
                COUNT({fk_field}) as mapped,
                COUNT(CASE WHEN {fk_field} IS NULL AND definition IS NOT NULL THEN 1 END) as unmapped
            FROM mcl.{table_name} obj
            JOIN mcl.postgres_tables pt ON obj.table_id = pt.id
            JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
            WHERE mt.task_id = %s
        ''', (task_id,))
        
        stats = cursor.fetchone()
        validation_results['object_type_breakdown'][object_type] = {
            'total': stats[0],
            'mapped': stats[1],
            'unmapped': stats[2]
        }
        
        validation_results['total_objects'] += stats[0]
        validation_results['mapped_objects'] += stats[1]
        validation_results['unmapped_objects'] += stats[2]
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª
    cursor.execute('''
        SELECT 
            fmr.source_function,
            fmr.target_function,
            fmr.complexity_level,
            COUNT(pdc.id) as default_constraints_count,
            COUNT(pc.id) as computed_columns_count,
            COUNT(pcc.id) as check_constraints_count,
            COUNT(pi.id) as indexes_count,
            (COUNT(pdc.id) + COUNT(pc.id) + COUNT(pcc.id) + COUNT(pi.id)) as total_usage
        FROM mcl.function_mapping_rules fmr
        LEFT JOIN mcl.postgres_default_constraints pdc ON fmr.id = pdc.function_mapping_rule_id
        LEFT JOIN mcl.postgres_columns pc ON fmr.id = pc.computed_function_mapping_rule_id
        LEFT JOIN mcl.postgres_check_constraints pcc ON fmr.id = pcc.function_mapping_rule_id
        LEFT JOIN mcl.postgres_indexes pi ON fmr.id = pi.function_mapping_rule_id
        GROUP BY fmr.id, fmr.source_function, fmr.target_function, fmr.complexity_level
        HAVING (COUNT(pdc.id) + COUNT(pc.id) + COUNT(pcc.id) + COUNT(pi.id)) > 0
        ORDER BY total_usage DESC
    ''')
    
    rule_stats = cursor.fetchall()
    validation_results['rule_usage_statistics'] = rule_stats
    
    # –ê–Ω–∞–ª–∏–∑ –ø–æ–∫—Ä—ã—Ç–∏—è
    validation_results['coverage_analysis'] = {
        'coverage_percentage': (validation_results['mapped_objects'] / validation_results['total_objects'] * 100) if validation_results['total_objects'] > 0 else 0,
        'ready_for_migration': validation_results['unmapped_objects'] == 0,
        'object_types_ready': {obj_type: data['unmapped'] == 0 for obj_type, data in validation_results['object_type_breakdown'].items()}
    }
    
    return validation_results
```

---

## üìä –ü–†–ò–ú–ï–†–´ –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–• –ó–ê–ü–†–û–°–û–í

### **üîç –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ:**

```sql
-- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö –ø—Ä–∞–≤–∏–ª–æ getdate ‚Üí NOW
SELECT 
    'default_constraint' as object_type,
    pdc.constraint_name as object_name,
    pt.object_name as table_name,
    fmr.source_function,
    fmr.target_function,
    pdc.postgres_definition
FROM mcl.postgres_default_constraints pdc
JOIN mcl.function_mapping_rules fmr ON pdc.function_mapping_rule_id = fmr.id
JOIN mcl.postgres_tables pt ON pdc.table_id = pt.id
WHERE fmr.source_function = 'getdate'

UNION ALL

SELECT 
    'computed_column' as object_type,
    pc.column_name as object_name,
    pt.object_name as table_name,
    fmr.source_function,
    fmr.target_function,
    pc.postgres_computed_definition
FROM mcl.postgres_columns pc
JOIN mcl.function_mapping_rules fmr ON pc.computed_function_mapping_rule_id = fmr.id
JOIN mcl.postgres_tables pt ON pc.table_id = pt.id
WHERE fmr.source_function = 'getdate'

UNION ALL

SELECT 
    'check_constraint' as object_type,
    pcc.constraint_name as object_name,
    pt.object_name as table_name,
    fmr.source_function,
    fmr.target_function,
    pcc.postgres_definition
FROM mcl.postgres_check_constraints pcc
JOIN mcl.function_mapping_rules fmr ON pcc.function_mapping_rule_id = fmr.id
JOIN mcl.postgres_tables pt ON pcc.table_id = pt.id
WHERE fmr.source_function = 'getdate'

UNION ALL

SELECT 
    'index' as object_type,
    pi.index_name as object_name,
    pt.object_name as table_name,
    fmr.source_function,
    fmr.target_function,
    pi.postgres_definition
FROM mcl.postgres_indexes pi
JOIN mcl.function_mapping_rules fmr ON pi.function_mapping_rule_id = fmr.id
JOIN mcl.postgres_tables pt ON pi.table_id = pt.id
WHERE fmr.source_function = 'getdate';
```

### **üìà –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª:**

```sql
-- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞
SELECT 
    fmr.source_function,
    fmr.target_function,
    fmr.complexity_level,
    fmr.applicable_objects,
    COUNT(pdc.id) as default_constraints_count,
    COUNT(pc.id) as computed_columns_count,
    COUNT(pcc.id) as check_constraints_count,
    COUNT(pi.id) as indexes_count,
    (COUNT(pdc.id) + COUNT(pc.id) + COUNT(pcc.id) + COUNT(pi.id)) as total_usage
FROM mcl.function_mapping_rules fmr
LEFT JOIN mcl.postgres_default_constraints pdc ON fmr.id = pdc.function_mapping_rule_id
LEFT JOIN mcl.postgres_columns pc ON fmr.id = pc.computed_function_mapping_rule_id
LEFT JOIN mcl.postgres_check_constraints pcc ON fmr.id = pcc.function_mapping_rule_id
LEFT JOIN mcl.postgres_indexes pi ON fmr.id = pi.function_mapping_rule_id
WHERE fmr.is_active = TRUE
GROUP BY fmr.id, fmr.source_function, fmr.target_function, fmr.complexity_level, fmr.applicable_objects
ORDER BY total_usage DESC;
```

### **üìã –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ —Å—Ç–∞—Ç—É—Å—É –º–∞–ø–ø–∏–Ω–≥–∞:**

```sql
-- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ —Å—Ç–∞—Ç—É—Å—É –º–∞–ø–ø–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –∑–∞–¥–∞—á–∏
SELECT 
    'default_constraints' as object_type,
    mapping_status,
    COUNT(*) as count
FROM mcl.postgres_default_constraints pdc
JOIN mcl.postgres_tables pt ON pdc.table_id = pt.id
JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
WHERE mt.task_id = 2
GROUP BY mapping_status

UNION ALL

SELECT 
    'computed_columns' as object_type,
    computed_mapping_status as mapping_status,
    COUNT(*) as count
FROM mcl.postgres_columns pc
JOIN mcl.postgres_tables pt ON pc.table_id = pt.id
JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
WHERE mt.task_id = 2
GROUP BY computed_mapping_status

UNION ALL

SELECT 
    'check_constraints' as object_type,
    mapping_status,
    COUNT(*) as count
FROM mcl.postgres_check_constraints pcc
JOIN mcl.postgres_tables pt ON pcc.table_id = pt.id
JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
WHERE mt.task_id = 2
GROUP BY mapping_status

UNION ALL

SELECT 
    'indexes' as object_type,
    mapping_status,
    COUNT(*) as count
FROM mcl.postgres_indexes pi
JOIN mcl.postgres_tables pt ON pi.table_id = pt.id
JOIN mcl.mssql_tables mt ON pt.source_table_id = mt.id
WHERE mt.task_id = 2
GROUP BY mapping_status
ORDER BY object_type, mapping_status;
```

---

## üöÄ –ü–õ–ê–ù –í–ù–ï–î–†–ï–ù–ò–Ø –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ì–û –†–ï–®–ï–ù–ò–Ø

### **–≠—Ç–∞–ø 1: –°–æ–∑–¥–∞–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –≤–Ω–µ—à–Ω–∏–º–∏ –∫–ª—é—á–∞–º–∏**
1. –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã `function_mapping_rules` —Å –ø–æ–ª–µ–º `applicable_objects`
2. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ `postgres_default_constraints` —Å –≤–Ω–µ—à–Ω–∏–º –∫–ª—é—á–æ–º
3. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ `postgres_columns` —Å –≤–Ω–µ—à–Ω–∏–º –∫–ª—é—á–æ–º
4. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ `postgres_check_constraints` —Å –≤–Ω–µ—à–Ω–∏–º –∫–ª—é—á–æ–º
5. –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ `postgres_indexes` —Å –≤–Ω–µ—à–Ω–∏–º –∫–ª—é—á–æ–º
6. –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–æ–≤ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### **–≠—Ç–∞–ø 2: –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª –º–∞–ø–ø–∏–Ω–≥–∞**
1. –í—Å—Ç–∞–≤–∫–∞ –ø—Ä–∞–≤–∏–ª —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø—Ä–∏–º–µ–Ω–∏–º—ã—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤
2. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –Ω–∞ –≤—Å–µ—Ö —Ç–∏–ø–∞—Ö –æ–±—ä–µ–∫—Ç–æ–≤
3. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª

### **–≠—Ç–∞–ø 3: –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ –º–∞–ø–ø–∏–Ω–≥–∞ —Å –≤–Ω–µ—à–Ω–∏–º–∏ –∫–ª—é—á–∞–º–∏**
1. –ê–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ñ—É–Ω–∫—Ü–∏–π
2. –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–µ –∫–ª—é—á–∏
3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è PostgreSQL –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
4. –ó–∞–ø–∏—Å—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ

### **–≠—Ç–∞–ø 4: –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∏ –æ—Ç—á–µ—Ç—ã**
1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Å–≤—è–∑–µ–π –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª
3. –í—ã—è–≤–ª–µ–Ω–∏–µ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
4. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø—Ä–∞–≤–∏–ª –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏

---

## üéØ –û–ñ–ò–î–ê–ï–ú–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´ –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ì–û –†–ï–®–ï–ù–ò–Ø

–ü–æ—Å–ª–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ –∫–ª—é—á–∞–º–∏:

1. **84 —Ç–µ–∫—É—â–∏—Ö —Å–ª—É—á–∞—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π** –±—É–¥—É—Ç —Å–≤—è–∑–∞–Ω—ã —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–µ –∫–ª—é—á–∏
2. **181 –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Å–ª—É—á–∞–π** –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤ –∫ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π
3. **4 —Ç–∏–ø–∞ –æ–±—ä–µ–∫—Ç–æ–≤** –±—É–¥—É—Ç –ø–æ–∫—Ä—ã—Ç—ã –µ–¥–∏–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π –º–∞–ø–ø–∏–Ω–≥–∞
4. **–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ** –ø—Ä–∞–≤–∏–ª–∞–º–∏ –º–∞–ø–ø–∏–Ω–≥–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
5. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ** –≤—Å–µ—Ö —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª
6. **–ü–æ–ª–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä—É–µ–º–æ—Å—Ç—å** –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∞–≤–∏–ª –∫–æ –≤—Å–µ–º —Ç–∏–ø–∞–º –æ–±—ä–µ–∫—Ç–æ–≤
7. **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã** –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏ –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏ –ø–æ –≤—Å–µ–º —Ç–∏–ø–∞–º
8. **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å** –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –ø—Ä–∞–≤–∏–ª

---

## üèÜ –ó–ê–ö–õ–Æ–ß–ï–ù–ò–ï

**–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–∞–ø–ø–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏–π —Å –≤–Ω–µ—à–Ω–∏–º–∏ –∫–ª—é—á–∞–º–∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:**

- ‚úÖ **–ü–æ–ª–Ω–æ—Ç—É –ø–æ–∫—Ä—ã—Ç–∏—è** - –≤—Å–µ —Ç–∏–ø—ã –æ–±—ä–µ–∫—Ç–æ–≤ —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –ø–æ–∫—Ä—ã—Ç—ã
- ‚úÖ **–ü—Ä–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å** - –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –±—É–¥—É—â–∏–º —Ñ—É–Ω–∫—Ü–∏—è–º
- ‚úÖ **–ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å** - –µ–¥–∏–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –∫–æ –≤—Å–µ–º –æ–±—ä–µ–∫—Ç–∞–º
- ‚úÖ **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å** - –ª–µ–≥–∫–æ—Å—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Ç–∏–ø–æ–≤
- ‚úÖ **–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å** - –æ–¥–∏–Ω —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –ø—Ä–∞–≤–∏–ª –¥–ª—è –≤—Å–µ—Ö
- ‚úÖ **–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö** - –∏–∑–±–µ–∂–∞–Ω–∏–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª
- ‚úÖ **–£–ø—Ä–∞–≤–ª—è–µ–º–æ—Å—Ç—å** - —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª–∞–º–∏
- ‚úÖ **–¢—Ä–∞—Å—Å–∏—Ä—É–µ–º–æ—Å—Ç—å** - —á–µ—Ç–∫–∞—è —Å–≤—è–∑—å –æ–±—ä–µ–∫—Ç–æ–≤ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏
- ‚úÖ **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ JOIN –∑–∞–ø—Ä–æ—Å—ã
- ‚úÖ **–ì–∏–±–∫–æ—Å—Ç—å** - –ª–µ–≥–∫–æ—Å—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏

**–≠—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –º–∏–≥—Ä–∞—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π MS SQL Server –≤ PostgreSQL —Å –ø–æ–ª–Ω—ã–º –ø–æ–∫—Ä—ã—Ç–∏–µ–º –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.**